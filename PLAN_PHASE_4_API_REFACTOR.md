# Phase 4: Refactor API Route to Use Pre-Built JSON

## Overview

Refactor the `/r/[...params]` API route to serve pre-built JSON files generated by `@dotui/registry-builder` (Phase 3). This eliminates runtime filesystem access, enables edge deployment, and dramatically improves response times.

**Key Principle:** Runtime only applies lightweight transforms and style-specific customizations. All heavy filesystem operations happened at build time.

---

## Current Flow (Problems)

```
Request → Read files from disk → Transform with ts-morph → Respond
```

**Issues:**

- Runtime filesystem access (slow, not edge-compatible)
- Heavy processing per request
- No caching
- Coupled to filesystem structure

---

## New Flow (Target)

```
Build time:  Registry source → registry-builder → dist/ui/{component}.json

Runtime:     Request → Read pre-built JSON → Apply transforms → Cache → Respond
```

**Benefits:**

- Edge-compatible (no filesystem access)
- Sub-millisecond JSON reads
- Cacheable at CDN/Redis level
- Style transforms are lightweight string operations

---

## Package Structure Changes

### 4.1 New File Structure in `www/`

```
www/
├── app/
│   └── r/
│       └── [...params]/
│           └── route.ts              # Refactored API route
├── lib/
│   └── registry/
│       ├── index.ts                  # Public exports
│       ├── loader.ts                 # JSON loader (static import or fetch)
│       ├── transformer.ts            # Style-specific transforms
│       └── cache.ts                  # In-memory cache (optional)
```

---

## 4.2 Pre-Built JSON Loader

Create `www/lib/registry/loader.ts`:

```typescript
import type { ComponentJson, Manifest } from "@dotui/registry-builder";

// Path to pre-built registry files
const REGISTRY_DIST_PATH = "../packages/registry/dist";

// In-memory manifest cache
let manifestCache: Manifest | null = null;

/**
 * Load the registry manifest (index of all components)
 */
export async function loadManifest(): Promise<Manifest> {
  if (manifestCache) {
    return manifestCache;
  }

  // In production, this would be a static import or CDN fetch
  const manifest = await import(`${REGISTRY_DIST_PATH}/index.json`).then(
    (m) => m.default
  );

  manifestCache = manifest;
  return manifest;
}

/**
 * Load a specific component's pre-built JSON
 */
export async function loadComponentJson(
  name: string,
  category: string = "ui"
): Promise<ComponentJson | null> {
  try {
    const json = await import(
      `${REGISTRY_DIST_PATH}/${category}/${name}.json`
    ).then((m) => m.default);

    return json;
  } catch {
    return null;
  }
}

/**
 * Load special registry items (theme, base, all)
 */
export async function loadSpecialItem(
  name: "theme" | "base" | "all" | "registry"
): Promise<unknown> {
  try {
    const json = await import(`${REGISTRY_DIST_PATH}/${name}.json`).then(
      (m) => m.default
    );

    return json;
  } catch {
    return null;
  }
}
```

---

## 4.3 Style-Specific Transformer

Create `www/lib/registry/transformer.ts`:

```typescript
import {
  applyTransforms,
  transformIcons,
  transformImports,
  type TransformContext,
} from "@dotui/transformers";
import type { ComponentJson, FileEntry } from "@dotui/registry-builder";
import type { Style, ColorFormat } from "@dotui/style-system";

import { registryIcons } from "@dotui/registry/icons/registry";

export interface TransformOptions {
  style: Style;
  styleName: string;
  baseUrl: string;
  colorFormat?: ColorFormat;
}

/**
 * Apply style-specific transforms to pre-built component JSON
 */
export function transformComponentJson(
  component: ComponentJson,
  options: TransformOptions
): ComponentJson {
  const { style } = options;

  // Build transform context from style
  const targetIconLibrary =
    style.icons.library === "remix" ? "remix" : "lucide";

  const context: TransformContext = {
    iconLibrary: targetIconLibrary,
    iconMap: registryIcons as Record<string, Record<string, string>>,
  };

  // Transform all files in the component
  const transformedFiles = component.files.map((file) =>
    transformFile(file, context)
  );

  // Transform variant files if present
  let transformedVariants = component.variants;
  if (component.variants) {
    transformedVariants = {};
    for (const [variantName, variantData] of Object.entries(
      component.variants
    )) {
      transformedVariants[variantName] = {
        files: variantData.files.map((file) => transformFile(file, context)),
      };
    }
  }

  return {
    ...component,
    files: transformedFiles,
    variants: transformedVariants,
  };
}

function transformFile(file: FileEntry, context: TransformContext): FileEntry {
  if (!file.content) {
    return file;
  }

  const transformedContent = applyTransforms(
    file.content,
    [transformImports, transformIcons],
    context
  );

  return {
    ...file,
    content: transformedContent,
  };
}

/**
 * Generate theme JSON with style-specific CSS variables
 */
export function generateThemeJson(
  style: Style,
  styleName: string,
  colorFormat: ColorFormat
): unknown {
  return {
    name: styleName,
    type: "registry:style",
    tailwind: {
      config: {
        theme: {
          extend: {},
        },
      },
    },
    cssVars: {
      light: style.theme.css?.light || {},
      dark: style.theme.css?.dark || {},
    },
  };
}
```

---

## 4.4 Optional In-Memory Cache

Create `www/lib/registry/cache.ts`:

```typescript
interface CacheEntry<T> {
  data: T;
  timestamp: number;
}

const cache = new Map<string, CacheEntry<unknown>>();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

/**
 * Get cached value or compute and cache it
 */
export async function cached<T>(
  key: string,
  compute: () => Promise<T>
): Promise<T> {
  const entry = cache.get(key) as CacheEntry<T> | undefined;

  if (entry && Date.now() - entry.timestamp < CACHE_TTL) {
    return entry.data;
  }

  const data = await compute();
  cache.set(key, { data, timestamp: Date.now() });

  return data;
}

/**
 * Generate cache key for style + component combination
 */
export function getCacheKey(
  styleName: string,
  componentName: string,
  colorFormat: string
): string {
  return `${styleName}:${componentName}:${colorFormat}`;
}

/**
 * Clear cache (useful for development)
 */
export function clearCache(): void {
  cache.clear();
}
```

---

## 4.5 Refactored API Route

Update `www/app/r/[...params]/route.ts`:

```typescript
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

import { createStyle } from "@dotui/style-system";
import type { RouterOutputs } from "@dotui/api";
import type { ColorFormat } from "@dotui/style-system";

import { env } from "@/env";
import { caller } from "@/lib/trpc/server";
import { loadComponentJson, loadSpecialItem } from "@/lib/registry/loader";
import {
  transformComponentJson,
  generateThemeJson,
} from "@/lib/registry/transformer";
import { cached, getCacheKey } from "@/lib/registry/cache";

export const runtime = "edge"; // Enable edge runtime

export async function GET(
  request: NextRequest,
  { params }: RouteContext<"/r/[...params]">
) {
  try {
    const { params: routeParams } = await params;
    const { searchParams } = new URL(request.url);

    // Get color format from query params, default to "oklch"
    const colorFormat = (searchParams.get("format") as ColorFormat) || "oklch";

    // Validate color format
    if (!["oklch", "hex", "hsl"].includes(colorFormat)) {
      return NextResponse.json(
        { error: "Invalid color format. Must be one of: oklch, hex, hsl" },
        { status: 400 }
      );
    }

    if (
      !routeParams ||
      (routeParams.length !== 2 && routeParams.length !== 3)
    ) {
      return NextResponse.json(
        {
          error:
            "Invalid URL format. Expected /r/{username}/{style}/{name} or /r/{style}/{name}",
        },
        { status: 400 }
      );
    }

    // Parse route params
    let style: RouterOutputs["style"]["getBySlug"];
    let styleSlug: string;
    let registryItemName: string;

    if (routeParams.length === 3) {
      const [username, styleName, name] = routeParams as [
        string,
        string,
        string
      ];
      registryItemName = name;
      styleSlug = `${username}/${styleName}`;
    } else {
      const [styleName, name] = routeParams as [string, string];
      registryItemName = name;
      styleSlug = styleName;
    }

    // Fetch style from database
    style = await caller.style.getBySlug({ slug: styleSlug });

    if (!style) {
      return NextResponse.json({ error: "Style not found" }, { status: 404 });
    }

    // Generate style object
    const styleObj = createStyle(style, false, colorFormat);

    // Handle special items
    if (registryItemName === "registry") {
      const registry = await loadSpecialItem("registry");
      return NextResponse.json(registry);
    }

    if (registryItemName === "theme") {
      const themeJson = generateThemeJson(styleObj, styleSlug, colorFormat);
      return NextResponse.json(themeJson);
    }

    if (registryItemName === "base") {
      const base = await loadSpecialItem("base");
      return NextResponse.json(base);
    }

    if (registryItemName === "all") {
      const all = await loadSpecialItem("all");
      return NextResponse.json(all);
    }

    // Load pre-built component JSON with caching
    const cacheKey = getCacheKey(styleSlug, registryItemName, colorFormat);

    const result = await cached(cacheKey, async () => {
      // Load pre-built JSON
      const component = await loadComponentJson(registryItemName);

      if (!component) {
        return null;
      }

      // Apply style-specific transforms
      return transformComponentJson(component, {
        style: styleObj,
        styleName: styleSlug,
        baseUrl:
          env.NODE_ENV === "development"
            ? "http://localhost:4444/r"
            : "https://dotui.org/r",
        colorFormat,
      });
    });

    if (!result) {
      return NextResponse.json(
        { error: "Registry item not found" },
        { status: 404 }
      );
    }

    // Return with cache headers
    const response = NextResponse.json(result);
    response.headers.set(
      "Cache-Control",
      "public, s-maxage=60, stale-while-revalidate=300"
    );

    return response;
  } catch (_error) {
    console.error("Registry API error:", _error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

---

## 4.6 Build Integration

Update `packages/registry/package.json` scripts:

```json
{
  "scripts": {
    "build": "pnpm build:registry && pnpm build:json",
    "build:registry": "tsx scripts/build-registry.ts",
    "build:json": "registry-builder --src ./src --out ./dist"
  }
}
```

Add `dist/` to `.gitignore` or commit it based on deployment strategy.

---

## 4.7 Deployment Options

### Option A: Build at Deploy Time

```yaml
# vercel.json or similar
{ "buildCommand": "pnpm build", "outputDirectory": ".next" }
```

Pre-built JSON is generated during `pnpm build` and bundled with deployment.

### Option B: CDN-Hosted JSON

```typescript
// Alternative loader.ts for CDN-hosted JSON
const CDN_BASE = "https://cdn.dotui.org/registry/v1";

export async function loadComponentJson(
  name: string
): Promise<ComponentJson | null> {
  const response = await fetch(`${CDN_BASE}/ui/${name}.json`, {
    next: { revalidate: 3600 }, // Cache for 1 hour
  });

  if (!response.ok) return null;
  return response.json();
}
```

### Option C: Static Import (Build-time Bundling)

```typescript
// For smaller registries, import all JSON at build time
import * as components from "@dotui/registry/dist/index";

export function loadComponentJson(name: string): ComponentJson | null {
  return components[name] ?? null;
}
```

---

## Files to Create

1. `www/lib/registry/index.ts`
2. `www/lib/registry/loader.ts`
3. `www/lib/registry/transformer.ts`
4. `www/lib/registry/cache.ts`

## Files to Update

1. `www/app/r/[...params]/route.ts` - Complete refactor

## Files to Delete

After Phase 4 is verified working:

1. `packages/registry/src/shadcn-registry/generators/` - All runtime generators
2. `packages/registry/src/shadcn-registry/helpers/` - Move needed helpers to registry-builder

---

## Performance Comparison

| Metric          | Before (Current)    | After (Phase 4)    |
| --------------- | ------------------- | ------------------ |
| Cold Start      | ~500ms (file reads) | ~10ms (JSON parse) |
| Warm Request    | ~200ms              | ~5ms               |
| Edge Compatible | ❌                  | ✅                 |
| CDN Cacheable   | ⚠️ (limited)        | ✅ (fully)         |
| Memory Usage    | High (ts-morph)     | Low                |

---

## Migration Checklist

- [ ] Complete Phase 3 (registry-builder generates JSON)
- [ ] Create `www/lib/registry/` utilities
- [ ] Refactor API route
- [ ] Test all component types (ui, lib, hooks, blocks)
- [ ] Test special items (registry, theme, base, all)
- [ ] Test variants resolution
- [ ] Verify icon transforms work correctly
- [ ] Add cache headers
- [ ] Enable edge runtime
- [ ] Load test to verify performance
- [ ] Clean up old generator code

---

## Dependencies

- **Depends on:** Phase 3 (@dotui/registry-builder must generate JSON files)
- **Uses:** @dotui/transformers (for runtime transforms)
- **Uses:** @dotui/style-system (for style creation)

---

## Rollback Plan

If issues are found:

1. Revert `route.ts` to use `buildRegistryItem`
2. Keep old generators until Phase 4 is stable
3. Feature flag: `USE_PREBUILT_JSON=true/false` in env

```typescript
// Feature flagged route
if (env.USE_PREBUILT_JSON) {
  // New path: load pre-built JSON
} else {
  // Old path: use buildRegistryItem
}
```
