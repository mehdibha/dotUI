{
  "name": "overlay",
  "type": "registry:core",
  "dependencies": [
    "react-aria-components"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "core/overlay/overlay.tsx",
      "content": "\"use client\";\r\n\r\nimport React from \"react\";\r\nimport {\r\n  composeRenderProps,\r\n  Popover as AriaPopover,\r\n  OverlayArrow as AriaOverlayArrow,\r\n  Modal as AriaModal,\r\n  ModalOverlay as AriaModalOverlay,\r\n  OverlayTriggerStateContext as AriaOverlayTriggerStateContext,\r\n  type PopoverProps as AriaPopoverProps,\r\n  type ModalOverlayProps as AriaModalOverlayProps,\r\n} from \"react-aria-components\";\r\nimport { tv } from \"tailwind-variants\";\r\nimport { useMediaQuery } from \"@/lib/hooks/use-media-query\";\r\nimport { XIcon } from \"@/lib/icons\";\r\nimport { Button, type ButtonProps } from \"@/registry/ui/default/core/button\";\r\nimport { cn } from \"@/registry/ui/default/lib/cn\";\r\nimport { MotionDrawerRoot, useMotionDrawer } from \"./use-motion-drawer\";\r\n\r\ntype OverlayType = \"modal\" | \"drawer\" | \"popover\";\r\n\r\ntype OverlayProps = {\r\n  type?: OverlayType;\r\n  mobileType?: OverlayProps[\"type\"];\r\n  showDismissButton?: boolean;\r\n  mediaQuery?: string;\r\n  children: React.ReactNode;\r\n  classNames?: ModalOverlayClassNames &\r\n    DrawerOverlayClassNames &\r\n    PopoverOverlayClassNames;\r\n} & Omit<AriaModalOverlayProps, \"children\"> &\r\n  Omit<AriaPopoverProps, \"children\">;\r\n\r\nconst Overlay = React.forwardRef<HTMLElement | HTMLDivElement, OverlayProps>(\r\n  (\r\n    {\r\n      type: typeProp = \"modal\",\r\n      mobileType,\r\n      mediaQuery = \"(max-width: 640px)\",\r\n      isDismissable = true,\r\n      ...props\r\n    },\r\n    ref\r\n  ) => {\r\n    const isMobile = useMediaQuery(mediaQuery);\r\n    const type = mobileType ? (isMobile ? mobileType : typeProp) : typeProp;\r\n    switch (type) {\r\n      case \"modal\":\r\n        return (\r\n          <ModalOverlay\r\n            ref={ref as React.ForwardedRef<HTMLDivElement>}\r\n            isDismissable={isDismissable}\r\n            {...props}\r\n          />\r\n        );\r\n      case \"drawer\":\r\n        return (\r\n          // @ts-expect-error TODO FIX THIS SAME ORIENTATION PROP AS POPOVER :'(\r\n          <DrawerOverlay\r\n            ref={ref as React.ForwardedRef<HTMLDivElement>}\r\n            isDismissable={isDismissable}\r\n            {...props}\r\n          />\r\n        );\r\n      case \"popover\":\r\n        return (\r\n          <PopoverOverlay\r\n            ref={ref as React.ForwardedRef<HTMLElement>}\r\n            {...props}\r\n          />\r\n        );\r\n    }\r\n  }\r\n);\r\nOverlay.displayName = \"Overlay\";\r\n\r\nconst modalVariants = tv({\r\n  slots: {\r\n    backdrop: [\r\n      \"fixed inset-0 z-50 bg-black/80\",\r\n      \"data-[exiting]:duration-300 data-[entering]:animate-in data-[exiting]:animate-out data-[entering]:fade-in-0 data-[exiting]:fade-out-0\",\r\n    ],\r\n    overlay: [\r\n      \"group/overlay fixed left-[50%] top-[50%] z-50 w-full max-w-lg translate-x-[-50%] translate-y-[-50%]\",\r\n      \"border bg-bg shadow-lg sm:rounded-lg md:w-full\",\r\n      \"duration-200 data-[exiting]:duration-300 data-[entering]:animate-in data-[exiting]:animate-out data-[entering]:fade-in-0 data-[exiting]:fade-out-0 data-[entering]:zoom-in-95 data-[exiting]:zoom-out-95 data-[entering]:slide-in-from-left-1/2 data-[entering]:slide-in-from-top-[48%] data-[exiting]:slide-out-to-left-1/2 data-[exiting]:slide-out-to-top-[48%]\",\r\n    ],\r\n  },\r\n});\r\n\r\ntype ModalOverlaySlots = keyof ReturnType<typeof modalVariants>;\r\ntype ModalOverlayClassNames = {\r\n  [key in ModalOverlaySlots]?: string;\r\n};\r\n\r\ninterface ModalOverlayProps extends AriaModalOverlayProps {\r\n  showDismissButton?: boolean;\r\n  classNames?: ModalOverlayClassNames;\r\n}\r\n\r\nconst ModalOverlay = React.forwardRef<\r\n  React.ElementRef<typeof AriaModalOverlay>,\r\n  ModalOverlayProps\r\n>(\r\n  (\r\n    { classNames, className, isDismissable, showDismissButton, ...props },\r\n    ref\r\n  ) => {\r\n    const { overlay, backdrop } = modalVariants({});\r\n    return (\r\n      <AriaModalOverlay\r\n        {...props}\r\n        ref={ref}\r\n        isDismissable={isDismissable}\r\n        className={backdrop({ className: classNames?.backdrop })}\r\n      >\r\n        <AriaModal\r\n          {...props}\r\n          data-type=\"modal\"\r\n          className={cn(overlay(), classNames?.overlay, className)}\r\n        >\r\n          {composeRenderProps(props.children, (children) => (\r\n            <>\r\n              {(showDismissButton ?? isDismissable) && <DismissButton />}\r\n              {children}\r\n            </>\r\n          ))}\r\n        </AriaModal>\r\n      </AriaModalOverlay>\r\n    );\r\n  }\r\n);\r\nModalOverlay.displayName = \"ModalOverlay\";\r\n\r\nconst popoverOverlayVariants = tv({\r\n  slots: {\r\n    overlay:\r\n      \"group/overlay z-50 rounded-md border bg-bg text-fg shadow-md data-[trigger=Select]:min-w-[--trigger-width] data-[trigger=ComboBox]:min-w-[--trigger-width]\",\r\n    arrow: [\r\n      \"block fill-bg stroke-1 stroke-border\",\r\n      \"group-placement-left:-rotate-90 group-placement-right:rotate-90 group-placement-bottom:rotate-180\",\r\n    ],\r\n  },\r\n});\r\n\r\ntype PopoverOverlaySlots = keyof ReturnType<typeof popoverOverlayVariants>;\r\ntype PopoverOverlayClassNames = {\r\n  [key in PopoverOverlaySlots]?: string;\r\n};\r\n\r\ninterface PopoverOverlayProps extends AriaPopoverProps {\r\n  arrow?: boolean;\r\n  classNames?: PopoverOverlayClassNames;\r\n  showDismissButton?: boolean;\r\n}\r\n\r\nconst PopoverOverlay = React.forwardRef<\r\n  React.ElementRef<typeof AriaPopover>,\r\n  PopoverOverlayProps\r\n>(\r\n  (\r\n    { arrow = false, className, showDismissButton, classNames, ...props },\r\n    ref\r\n  ) => {\r\n    const { overlay, arrow: arrowStyle } = popoverOverlayVariants({});\r\n    return (\r\n      <AriaPopover\r\n        data-type=\"popover\"\r\n        ref={ref}\r\n        {...props}\r\n        className={cn(overlay(), classNames?.overlay, className)}\r\n      >\r\n        {composeRenderProps(props.children, (children, {}) => (\r\n          <>\r\n            {showDismissButton && <DismissButton />}\r\n            {arrow && (\r\n              <AriaOverlayArrow className=\"group\">\r\n                <svg\r\n                  width={12}\r\n                  height={12}\r\n                  viewBox=\"0 0 12 12\"\r\n                  className={arrowStyle({ className: classNames?.arrow })}\r\n                >\r\n                  <path d=\"M0 0 L6 6 L12 0\" />\r\n                </svg>\r\n              </AriaOverlayArrow>\r\n            )}\r\n            {children}\r\n          </>\r\n        ))}\r\n      </AriaPopover>\r\n    );\r\n  }\r\n);\r\nPopoverOverlay.displayName = \"PopoverOverlay\";\r\n\r\nconst drawerVariants = tv({\r\n  slots: {\r\n    backdrop: [\"fixed inset-0 bg-black/60 z-50\", \"opacity-0\"],\r\n    overlay: [\r\n      \"group/overlay bg-bg flex flex-col fixed z-50 outline-none\",\r\n      \"inset-0\",\r\n      \"placement-bottom:top-auto placement-top:bottom-auto placement-left:right-auto placement-right:left-auto\",\r\n      \"placement-bottom:mt-24 placement-bottom:rounded-t-[10px] placement-bottom:border-t\",\r\n      \"placement-top:mb-24 placement-top:rounded-b-[10px] placement-top:border-b\",\r\n      \"placement-right:ml-24 placement-right:rounded-l-[10px] placement-right:border-l\",\r\n      \"placement-left:mr-24 placement-left:rounded-r-[10px] placement-left:border-r\",\r\n      \"touch-none will-change-transform\",\r\n      \"placement-bottom:translate-y-full placement-top:-translate-y-full placement-left:-translate-x-full placement-right:translate-x-full\", // required\r\n      \"max-h-[90%]\",\r\n    ],\r\n  },\r\n});\r\n\r\ntype DrawerOverlaySlots = keyof ReturnType<typeof drawerVariants>;\r\ntype DrawerOverlayClassNames = {\r\n  [key in DrawerOverlaySlots]?: string;\r\n};\r\n\r\ninterface DrawerOverlayProps extends Omit<AriaModalOverlayProps, \"children\"> {\r\n  placement?: \"top\" | \"bottom\" | \"left\" | \"right\";\r\n  showDismissButton?: boolean;\r\n  children?: React.ReactNode;\r\n  classNames?: DrawerOverlayClassNames;\r\n}\r\n\r\nconst DrawerOverlay = React.forwardRef<\r\n  React.ElementRef<typeof AriaModalOverlay>,\r\n  DrawerOverlayProps\r\n>(\r\n  (\r\n    {\r\n      children,\r\n      classNames,\r\n      className,\r\n      isDismissable,\r\n      showDismissButton = false,\r\n      placement = \"bottom\",\r\n      ...props\r\n    },\r\n    ref\r\n  ) => {\r\n    const { rootProps, modalProps, backdropProps, drawerProps } =\r\n      useMotionDrawer({\r\n        isDismissable,\r\n        placement,\r\n      });\r\n    const { overlay, backdrop } = drawerVariants();\r\n\r\n    return (\r\n      <MotionDrawerRoot {...rootProps}>\r\n        <AriaModalOverlay\r\n          ref={ref}\r\n          isDismissable={isDismissable}\r\n          {...props}\r\n          {...modalProps}\r\n        >\r\n          <div\r\n            {...backdropProps}\r\n            className={backdrop({ className: classNames?.backdrop })}\r\n          />\r\n          <AriaModal>\r\n            <div\r\n              {...drawerProps}\r\n              data-type=\"drawer\"\r\n              className={cn(overlay(), classNames?.overlay, className)}\r\n            >\r\n              {showDismissButton && (\r\n                <DismissButton shape=\"rectangle\">Done</DismissButton>\r\n              )}\r\n              <div className=\"mx-auto my-4 h-2 w-[100px] rounded-full bg-bg-muted\" />\r\n              {children}\r\n            </div>\r\n          </AriaModal>\r\n        </AriaModalOverlay>\r\n      </MotionDrawerRoot>\r\n    );\r\n  }\r\n);\r\nDrawerOverlay.displayName = \"DrawerOverlay\";\r\n\r\nconst DismissButton = (props: ButtonProps) => {\r\n  const state = React.useContext(AriaOverlayTriggerStateContext);\r\n  return (\r\n    <Button\r\n      shape=\"square\"\r\n      variant=\"quiet\"\r\n      size=\"sm\"\r\n      aria-label=\"Close\"\r\n      {...props}\r\n      className={cn(\"absolute right-2 top-2 z-20\", props.className)}\r\n      onPress={() => state.close()}\r\n    >\r\n      {props.children ?? <XIcon />}\r\n    </Button>\r\n  );\r\n};\r\n\r\nexport type {\r\n  OverlayProps,\r\n  ModalOverlayProps,\r\n  DrawerOverlayProps,\r\n  PopoverOverlayProps,\r\n};\r\nexport {\r\n  Overlay,\r\n  PopoverOverlay,\r\n  DrawerOverlay,\r\n  ModalOverlay,\r\n  drawerVariants,\r\n  modalVariants,\r\n  popoverOverlayVariants,\r\n};\r\n",
      "type": "registry:core",
      "target": ""
    },
    {
      "path": "core/overlay/use-motion-drawer.tsx",
      "content": "import React from \"react\";\r\nimport { OverlayTriggerStateContext } from \"react-aria-components\";\r\n\r\ninterface useMotionDrawerProps {\r\n  open?: boolean;\r\n  onOpenChange?: (open: boolean) => void;\r\n  scaleBackground?: boolean;\r\n  closeThreshold?: number;\r\n  scrollLockTimeout?: number;\r\n  isDismissable?: boolean;\r\n  placement?: \"top\" | \"bottom\" | \"left\" | \"right\";\r\n}\r\n\r\ntype AnimationState = \"unmounted\" | \"hidden\" | \"visible\";\r\n\r\nexport const useMotionDrawer = (props: useMotionDrawerProps) => {\r\n  const {\r\n    scaleBackground = true,\r\n    closeThreshold = CLOSE_THRESHOLD,\r\n    scrollLockTimeout = SCROLL_LOCK_TIMEOUT,\r\n    isDismissable = true,\r\n    placement = \"bottom\",\r\n  } = props;\r\n  const contextState = React.useContext(OverlayTriggerStateContext);\r\n  const context = React.useContext(DrawerInternalContext);\r\n  const state = contextState;\r\n  const [animation, setAnimation] = React.useState<AnimationState>(\"unmounted\");\r\n  const isEntering = animation === \"visible\";\r\n  const isExiting = animation === \"hidden\";\r\n  const nested = !!context;\r\n\r\n  const drawerRef = React.useRef<HTMLDivElement>(null);\r\n  const backdropRef = React.useRef<HTMLDivElement>(null);\r\n  const dragStartTime = React.useRef<Date | null>(null);\r\n  const dragEndTime = React.useRef<Date | null>(null);\r\n\r\n  const [isDragging, setDragging] = React.useState(false);\r\n  const drawerHeightRef = React.useRef(\r\n    drawerRef.current?.getBoundingClientRect().height || 0\r\n  );\r\n  const pointerStartRef = React.useRef<{ x: number; y: number } | null>(null);\r\n  const pointerStart = React.useRef(0);\r\n  const keyboardIsOpen = React.useRef(false);\r\n  const initialDrawerHeight = React.useRef(0);\r\n  const previousDiffFromInitial = React.useRef(0);\r\n\r\n  function shouldDrag(el: EventTarget) {\r\n    // TODO: add more conditions (scrollLockTimeout / when animating / placement right and left / swipe amout? / scrollable element / ...)\r\n    const selectedText = window.getSelection()?.toString();\r\n    if (selectedText && selectedText.length > 0) return false;\r\n    if (!isVertical(placement)) return true;\r\n    // TODO: Disallow drag when entering or exiting\r\n    const swipeAmount = drawerRef.current\r\n      ? getTranslate(drawerRef.current, placement)\r\n      : null;\r\n    if (\r\n      swipeAmount !== null &&\r\n      (placement === \"bottom\" ? swipeAmount > 0 : swipeAmount < 0)\r\n    )\r\n      return true;\r\n    // TODO: SCROLLLOCKTIMEOUT\r\n    // TODO: DRAG IN placement\r\n    let element = el as HTMLElement;\r\n    while (element) {\r\n      if (element.scrollHeight > element.clientHeight) {\r\n        if (element.scrollTop !== 0) {\r\n          return false;\r\n        }\r\n        if (element.getAttribute(\"role\") === \"dialog\") {\r\n          return true;\r\n        }\r\n      }\r\n      element = element.parentNode as HTMLElement;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function resetDrawer() {\r\n    if (!drawerRef.current) return;\r\n    const wrapper = document.querySelector(\"[drawer-wrapper]\");\r\n    const currentSwipeAmount = getTranslate(drawerRef.current, placement);\r\n    set(drawerRef.current, {\r\n      transform: \"translate3d(0, 0, 0)\",\r\n      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\r\n    });\r\n    set(backdropRef.current, {\r\n      transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\r\n      opacity: \"1\",\r\n    });\r\n    // TODO: put this in a function (resetBody)\r\n    if (\r\n      scaleBackground &&\r\n      currentSwipeAmount &&\r\n      currentSwipeAmount > 0 &&\r\n      state.isOpen &&\r\n      !nested\r\n    ) {\r\n      set(\r\n        wrapper,\r\n        {\r\n          borderRadius: `${BORDER_RADIUS}px`,\r\n          ...(isVertical(placement)\r\n            ? {\r\n                transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\r\n                transformOrigin: \"top\",\r\n              }\r\n            : {\r\n                transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\r\n                transformOrigin: \"left\",\r\n              }),\r\n          transitionProperty: \"transform, border-radius\",\r\n          transitionDuration: `${TRANSITIONS.DURATION}s`,\r\n          transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\r\n        },\r\n        true\r\n      );\r\n    }\r\n  }\r\n\r\n  function onPress(event: React.PointerEvent<HTMLDivElement>) {\r\n    if (drawerRef.current && !drawerRef.current.contains(event.target as Node))\r\n      return;\r\n    drawerHeightRef.current =\r\n      drawerRef.current?.getBoundingClientRect().height || 0;\r\n    setDragging(true);\r\n    dragStartTime.current = new Date();\r\n    // if (isIOS()) {\r\n    //   window.addEventListener('touchend', () => (isAllowedToDrag.current = false), { once: true });\r\n    // }\r\n    (event.target as HTMLElement).setPointerCapture(event.pointerId);\r\n    pointerStart.current = isVertical(placement)\r\n      ? event.clientY\r\n      : event.clientX;\r\n  }\r\n\r\n  function onDrag(event: React.PointerEvent<HTMLDivElement>) {\r\n    if (!drawerRef.current || !isDragging || !shouldDrag(event.target)) return;\r\n    const placementMultiplier =\r\n      placement === \"bottom\" || placement === \"right\" ? 1 : -1;\r\n    const draggedDistance =\r\n      (pointerStart.current -\r\n        (isVertical(placement) ? event.clientY : event.clientX)) *\r\n      placementMultiplier;\r\n    const isDraggingInDirection = draggedDistance > 0;\r\n    const absDraggedDistance = Math.abs(draggedDistance);\r\n    const wrapper = document.querySelector(\"[drawer-wrapper]\");\r\n    const percentageDragged = absDraggedDistance / drawerHeightRef.current;\r\n    if (nested) context.onNestedDrag(percentageDragged);\r\n    set(drawerRef.current, { transition: \"none\" }); // WHY?\r\n    set(backdropRef.current, { transition: \"none\" }); // WHY?\r\n    if (isDraggingInDirection) {\r\n      const dampenedDraggedDistance = dampenValue(draggedDistance);\r\n      const translateValue =\r\n        Math.min(dampenedDraggedDistance * -1, 0) * placementMultiplier;\r\n      set(drawerRef.current, {\r\n        transform: isVertical(placement)\r\n          ? `translate3d(0, ${translateValue}px, 0)`\r\n          : `translate3d(${translateValue}px, 0, 0)`,\r\n      });\r\n      return;\r\n    }\r\n    const opacityValue = 1 - percentageDragged;\r\n    set(\r\n      backdropRef.current,\r\n      { opacity: `${opacityValue}`, transition: \"none\" },\r\n      true\r\n    );\r\n    if (wrapper && backdropRef.current && scaleBackground && !nested) {\r\n      // Calculate percentageDragged as a fraction (0 to 1)\r\n      const scaleValue = Math.min(\r\n        getScale() + percentageDragged * (1 - getScale()),\r\n        1\r\n      );\r\n      const borderRadiusValue = 8 - percentageDragged * 8;\r\n      const translateValue = Math.max(0, 14 - percentageDragged * 14);\r\n      set(\r\n        wrapper,\r\n        {\r\n          borderRadius: `${borderRadiusValue}px`,\r\n          transform: isVertical(placement)\r\n            ? `scale(${scaleValue}) translate3d(0, ${translateValue}px, 0)`\r\n            : `scale(${scaleValue}) translate3d(${translateValue}px, 0, 0)`,\r\n          transition: \"none\",\r\n        },\r\n        true\r\n      );\r\n    }\r\n    const translateValue = absDraggedDistance * placementMultiplier;\r\n    set(drawerRef.current, {\r\n      transform: isVertical(placement)\r\n        ? `translate3d(0, ${translateValue}px, 0)`\r\n        : `translate3d(${translateValue}px, 0, 0)`,\r\n    });\r\n\r\n    // TODO: transform body\r\n  }\r\n\r\n  function onRelease(event: React.PointerEvent<HTMLDivElement>) {\r\n    if (!isDragging || !drawerRef.current) return;\r\n    if (nested) context.onNestedRelease(true);\r\n    setDragging(false);\r\n    dragEndTime.current = new Date();\r\n    const swipeAmount = getTranslate(drawerRef.current, placement);\r\n    if (!shouldDrag(event.target) || !swipeAmount || isNaN(swipeAmount)) return;\r\n    if (dragStartTime.current === null) return;\r\n    // TODO: check for justReleased (to not focus on an element on drag end)\r\n    const timeTaken =\r\n      dragEndTime.current.getTime() - dragStartTime.current.getTime();\r\n    const distMoved =\r\n      pointerStart.current -\r\n      (isVertical(placement) ? event.clientY : event.clientX);\r\n    const velocity = Math.abs(distMoved) / timeTaken;\r\n    if (\r\n      placement === \"bottom\" || placement === \"right\"\r\n        ? distMoved > 0\r\n        : distMoved < 0\r\n    ) {\r\n      resetDrawer();\r\n      return;\r\n    }\r\n    if (velocity > VELOCITY_THRESHOLD) {\r\n      closeDrawer();\r\n      return;\r\n    }\r\n    const visibleDrawerHeight = Math.min(\r\n      drawerRef.current.getBoundingClientRect().height ?? 0,\r\n      window.innerHeight\r\n    );\r\n    if (swipeAmount >= visibleDrawerHeight * closeThreshold) {\r\n      closeDrawer();\r\n      return;\r\n    }\r\n    resetDrawer();\r\n  }\r\n\r\n  function onPointerDown(event: React.PointerEvent<HTMLDivElement>) {\r\n    pointerStartRef.current = { x: event.clientX, y: event.clientY };\r\n    onPress(event);\r\n  }\r\n\r\n  function onPointerMove(event: React.PointerEvent<HTMLDivElement>) {\r\n    if (!pointerStartRef.current) return;\r\n    // TODO: Is allowed to swipe check?\r\n    onDrag(event);\r\n  }\r\n\r\n  function onPointerUp(event: React.PointerEvent<HTMLDivElement>) {\r\n    pointerStartRef.current = null;\r\n    onRelease(event);\r\n  }\r\n\r\n  function getScale() {\r\n    return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;\r\n  }\r\n\r\n  function animateBody() {\r\n    if (nested) return;\r\n    const wrapper = document.querySelector(\"[drawer-wrapper]\");\r\n    if (!wrapper || !scaleBackground) return;\r\n    set(document.body, {\r\n      background:\r\n        document.body.style.backgroundColor || document.body.style.background,\r\n    });\r\n    set(document.body, { background: \"black\" }, true);\r\n    set(wrapper, {\r\n      borderRadius: `${BORDER_RADIUS}px`,\r\n      ...(isVertical(placement)\r\n        ? {\r\n            transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\r\n            transformOrigin: \"top\",\r\n          }\r\n        : {\r\n            transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\r\n            transformOrigin: \"left\",\r\n          }),\r\n      transitionProperty: \"transform, border-radius\",\r\n      transitionDuration: `${TRANSITIONS.DURATION}s`,\r\n      transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\r\n    });\r\n  }\r\n\r\n  function resetBody() {\r\n    if (nested) return;\r\n    const wrapper = document.querySelector(\"[drawer-wrapper]\");\r\n    if (!wrapper || !scaleBackground) return;\r\n    reset(wrapper, \"overflow\");\r\n    reset(wrapper, \"transform\");\r\n    reset(wrapper, \"borderRadius\");\r\n    set(wrapper, {\r\n      transitionProperty: \"transform, border-radius\",\r\n      transitionDuration: `${TRANSITIONS.DURATION}s`,\r\n      transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\r\n    });\r\n  }\r\n\r\n  function openDrawer() {\r\n    if (!drawerRef.current) return;\r\n    if (nested) context.onNestedOpenChange(true);\r\n    setAnimation(\"visible\");\r\n    animateBody();\r\n    set(drawerRef.current, {\r\n      transform: `translate3d(0, 0, 0)`,\r\n      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\r\n    });\r\n    set(backdropRef.current, {\r\n      opacity: \"1\",\r\n      transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\r\n    });\r\n  }\r\n\r\n  function closeDrawer() {\r\n    if (!drawerRef.current) return;\r\n    if (nested) context.onNestedOpenChange(false);\r\n    setAnimation(\"hidden\");\r\n    resetBody();\r\n    set(drawerRef.current, {\r\n      transform: isVertical(placement)\r\n        ? `translate3d(0, ${placement === \"bottom\" ? \"100%\" : \"-100%\"}, 0)`\r\n        : `translate3d(${placement === \"right\" ? \"100%\" : \"-100%\"}, 0, 0)`,\r\n      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\r\n    });\r\n    set(backdropRef.current, {\r\n      opacity: \"0\",\r\n      transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\r\n    });\r\n  }\r\n\r\n  function handleTransitionEnd() {\r\n    if (isExiting) {\r\n      setAnimation(\"unmounted\");\r\n      reset(document.body);\r\n      state.close();\r\n    }\r\n  }\r\n\r\n  function handleOpenChange(isOpen: boolean) {\r\n    if (!isOpen) {\r\n      closeDrawer();\r\n    }\r\n  }\r\n\r\n  function handleNestedOpenChange(isOpen: boolean) {\r\n    const scale = isOpen\r\n      ? (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth\r\n      : 1;\r\n    const y = isOpen ? -NESTED_DISPLACEMENT : 0;\r\n    set(drawerRef.current, {\r\n      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\r\n      transform: `scale(${scale}) translate3d(0, ${y}px, 0)`,\r\n    });\r\n  }\r\n\r\n  function handleNestedDrag(percentageDragged: number) {\r\n    if (percentageDragged < 0) return;\r\n    const initialDim = isVertical(placement)\r\n      ? window.innerHeight\r\n      : window.innerWidth;\r\n    const initialScale = (initialDim - NESTED_DISPLACEMENT) / initialDim;\r\n    const newScale = initialScale + percentageDragged * (1 - initialScale);\r\n    const newTranslate =\r\n      -NESTED_DISPLACEMENT + percentageDragged * NESTED_DISPLACEMENT;\r\n    set(drawerRef.current, {\r\n      transform: isVertical(placement)\r\n        ? `scale(${newScale}) translate3d(0, ${newTranslate}px, 0)`\r\n        : `scale(${newScale}) translate3d(${newTranslate}px, 0, 0)`,\r\n      transition: \"none\",\r\n    });\r\n  }\r\n\r\n  function handleNestedRelease(isOpen: boolean) {\r\n    const dim = isVertical(placement) ? window.innerHeight : window.innerWidth;\r\n    const scale = isOpen ? (dim - NESTED_DISPLACEMENT) / dim : 1;\r\n    const translate = isOpen ? -NESTED_DISPLACEMENT : 0;\r\n    if (isOpen) {\r\n      set(drawerRef.current, {\r\n        transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\r\n        transform: isVertical(placement)\r\n          ? `scale(${scale}) translate3d(0, ${translate}px, 0)`\r\n          : `scale(${scale}) translate3d(${translate}px, 0, 0)`,\r\n      });\r\n    }\r\n  }\r\n\r\n  // TODO: ADD LOGIC FOR INPUT KEYBOARD OPEN ON MOBILE\r\n\r\n  React.useEffect(() => {\r\n    function onVisualViewportChange() {\r\n      if (!drawerRef.current) return;\r\n      const focusedElement = document.activeElement as HTMLElement;\r\n      if (isInput(focusedElement) || keyboardIsOpen.current) {\r\n        const visualViewportHeight = window.visualViewport?.height || 0;\r\n        const diffFromInitial = window.innerHeight - visualViewportHeight;\r\n        const drawerHeight =\r\n          drawerRef.current.getBoundingClientRect().height || 0;\r\n        if (!initialDrawerHeight.current) {\r\n          initialDrawerHeight.current = drawerHeight;\r\n        }\r\n        const offsetFromTop = drawerRef.current.getBoundingClientRect().top;\r\n        if (Math.abs(previousDiffFromInitial.current - diffFromInitial) > 60) {\r\n          keyboardIsOpen.current = !keyboardIsOpen.current;\r\n        }\r\n        previousDiffFromInitial.current = diffFromInitial;\r\n        if (drawerHeight > visualViewportHeight || keyboardIsOpen.current) {\r\n          const height = drawerRef.current.getBoundingClientRect().height;\r\n          let newDrawerHeight = height;\r\n          if (height > visualViewportHeight) {\r\n            newDrawerHeight = visualViewportHeight - WINDOW_TOP_OFFSET;\r\n          }\r\n          drawerRef.current.style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;\r\n        } else {\r\n          drawerRef.current.style.height = `${initialDrawerHeight.current}px`;\r\n        }\r\n        drawerRef.current.style.bottom = `${Math.max(diffFromInitial, 0)}px`;\r\n      }\r\n    }\r\n    window.visualViewport?.addEventListener(\"resize\", onVisualViewportChange);\r\n    return () =>\r\n      window.visualViewport?.removeEventListener(\r\n        \"resize\",\r\n        onVisualViewportChange\r\n      );\r\n  }, []);\r\n\r\n  React.useEffect(() => {\r\n    if (state.isOpen) {\r\n      openDrawer();\r\n    } else {\r\n      if (!nested) {\r\n        resetBody(); // to ensure that always the body is reset.\r\n      }\r\n    }\r\n    return () => {\r\n      resetBody();\r\n    };\r\n  }, [state.isOpen]);\r\n\r\n  const rootProps = {\r\n    value: {\r\n      onNestedOpenChange: handleNestedOpenChange,\r\n      onNestedDrag: handleNestedDrag,\r\n      onNestedRelease: handleNestedRelease,\r\n    },\r\n  };\r\n\r\n  const drawerProps = {\r\n    ref: drawerRef,\r\n    \"data-rac\": \"\",\r\n    \"data-drawer\": \"\",\r\n    \"data-placement\": placement,\r\n    \"data-open\": state.isOpen || undefined,\r\n    onTransitionEnd: handleTransitionEnd,\r\n    onPointerUp,\r\n    onPointerDown,\r\n    onPointerMove,\r\n  };\r\n\r\n  const modalProps = {\r\n    isOpen: state.isOpen,\r\n    onOpenChange: handleOpenChange,\r\n    isExiting,\r\n  };\r\n\r\n  const backdropProps = { ref: backdropRef };\r\n\r\n  return {\r\n    rootProps,\r\n    modalProps,\r\n    drawerProps,\r\n    backdropProps,\r\n  };\r\n};\r\n\r\nexport const MotionDrawerRoot = ({\r\n  children,\r\n  value,\r\n}: {\r\n  children: React.ReactNode;\r\n  value: DrawerInternalContextValue;\r\n}) => {\r\n  return (\r\n    <DrawerInternalContext.Provider value={value}>\r\n      {children}\r\n    </DrawerInternalContext.Provider>\r\n  );\r\n};\r\n\r\ninterface DrawerInternalContextValue {\r\n  onNestedOpenChange: (isOpen: boolean) => void;\r\n  onNestedDrag: (percentageDragged: number) => void;\r\n  onNestedRelease: (isOpen: boolean) => void;\r\n}\r\n\r\nexport const DrawerInternalContext =\r\n  React.createContext<DrawerInternalContextValue | null>(null);\r\n\r\nexport const useDrawerInternalContext = () => {\r\n  const context = React.useContext(DrawerInternalContext);\r\n  return context;\r\n};\r\n\r\n// Constants\r\n\r\nconst CLOSE_THRESHOLD = 0.25;\r\nconst SCROLL_LOCK_TIMEOUT = 100;\r\nconst BORDER_RADIUS = 8;\r\nconst WINDOW_TOP_OFFSET = 26;\r\nconst TRANSITIONS = {\r\n  DURATION: 0.5,\r\n  EASE: [0.32, 0.72, 0, 1],\r\n};\r\nconst VELOCITY_THRESHOLD = 0.4;\r\nconst NESTED_DISPLACEMENT = 16;\r\n\r\n// Types\r\n\r\ntype DrawerPlacement = \"top\" | \"bottom\" | \"left\" | \"right\";\r\n\r\n// Helpers\r\n\r\ntype Style = Record<string, string>;\r\n\r\nconst cache = new WeakMap();\r\n\r\nexport function isInView(el: HTMLElement): boolean {\r\n  const rect = el.getBoundingClientRect();\r\n\r\n  if (!window.visualViewport) return false;\r\n\r\n  return (\r\n    rect.top >= 0 &&\r\n    rect.left >= 0 &&\r\n    // Need + 40 for safari detection\r\n    rect.bottom <= window.visualViewport.height - 40 &&\r\n    rect.right <= window.visualViewport.width\r\n  );\r\n}\r\n\r\nexport function set(\r\n  el: Element | HTMLElement | null | undefined,\r\n  styles: Style,\r\n  ignoreCache = false\r\n) {\r\n  if (!el || !(el instanceof HTMLElement)) return;\r\n  const originalStyles: Style = {};\r\n\r\n  Object.entries(styles).forEach(([key, value]: [string, string]) => {\r\n    if (key.startsWith(\"--\")) {\r\n      el.style.setProperty(key, value);\r\n      return;\r\n    }\r\n\r\n    originalStyles[key] = (el.style as any)[key];\r\n    (el.style as any)[key] = value;\r\n  });\r\n\r\n  if (ignoreCache) return;\r\n\r\n  cache.set(el, originalStyles);\r\n}\r\n\r\nexport function reset(el: Element | HTMLElement | null, prop?: string) {\r\n  if (!el || !(el instanceof HTMLElement)) return;\r\n  const originalStyles = cache.get(el);\r\n\r\n  if (!originalStyles) {\r\n    return;\r\n  }\r\n\r\n  if (prop) {\r\n    (el.style as any)[prop] = originalStyles[prop];\r\n  } else {\r\n    Object.entries(originalStyles).forEach(([key, value]) => {\r\n      (el.style as any)[key] = value;\r\n    });\r\n  }\r\n}\r\n\r\nexport const isVertical = (placement: DrawerPlacement) => {\r\n  switch (placement) {\r\n    case \"top\":\r\n    case \"bottom\":\r\n      return true;\r\n    case \"left\":\r\n    case \"right\":\r\n      return false;\r\n    default:\r\n      return placement satisfies never;\r\n  }\r\n};\r\n\r\nexport function getTranslate(\r\n  element: HTMLElement,\r\n  placement: DrawerPlacement\r\n): number | null {\r\n  if (!element) {\r\n    return null;\r\n  }\r\n  const style = window.getComputedStyle(element);\r\n  const transform =\r\n    // @ts-ignore\r\n    style.transform || style.webkitTransform || style.mozTransform;\r\n  let mat = transform.match(/^matrix3d\\((.+)\\)$/);\r\n  if (mat) {\r\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\r\n    return parseFloat(mat[1].split(\", \")[isVertical(placement) ? 13 : 12]);\r\n  }\r\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\r\n  mat = transform.match(/^matrix\\((.+)\\)$/);\r\n  return mat\r\n    ? parseFloat(mat[1].split(\", \")[isVertical(placement) ? 5 : 4])\r\n    : null;\r\n}\r\n\r\nexport function dampenValue(v: number) {\r\n  return 8 * (Math.log(v + 1) - 2);\r\n}\r\n\r\n// Additional helpers\r\n\r\nfunction testPlatform(re: RegExp): boolean | undefined {\r\n  return window?.navigator != null\r\n    ? re.test(window.navigator.platform)\r\n    : undefined;\r\n}\r\n\r\nfunction isMac(): boolean | undefined {\r\n  return testPlatform(/^Mac/);\r\n}\r\n\r\nfunction isIPhone(): boolean | undefined {\r\n  return testPlatform(/^iPhone/);\r\n}\r\n\r\nfunction isIPad(): boolean | undefined {\r\n  return (\r\n    testPlatform(/^iPad/) ||\r\n    // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\r\n    (isMac() && navigator.maxTouchPoints > 1)\r\n  );\r\n}\r\n\r\nfunction isIOS(): boolean | undefined {\r\n  return isIPhone() || isIPad();\r\n}\r\n\r\nconst nonTextInputTypes = new Set([\r\n  \"checkbox\",\r\n  \"radio\",\r\n  \"range\",\r\n  \"color\",\r\n  \"file\",\r\n  \"image\",\r\n  \"button\",\r\n  \"submit\",\r\n  \"reset\",\r\n]);\r\nfunction isInput(target: Element) {\r\n  return (\r\n    (target instanceof HTMLInputElement &&\r\n      !nonTextInputTypes.has(target.type)) ||\r\n    target instanceof HTMLTextAreaElement ||\r\n    (target instanceof HTMLElement && target.isContentEditable)\r\n  );\r\n}\r\n",
      "type": "registry:core",
      "target": ""
    }
  ]
}