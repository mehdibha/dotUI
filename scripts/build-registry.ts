/**
 * Build Registry Script
 *
 * Generates __registry__/variants.ts from registry meta files.
 * Includes all components with variants.
 *
 * Usage: pnpm build:registry
 */

import * as fs from "node:fs";
import * as path from "node:path";

const ROOT_DIR = path.resolve(import.meta.dirname, "..");
const REGISTRY_UI_DIR = path.join(ROOT_DIR, "packages/registry/src/ui");
const OUTPUT_DIR = path.join(ROOT_DIR, "packages/core/src/__registry__");
const OUTPUT_FILE = path.join(OUTPUT_DIR, "variants.ts");

interface VariantInfo {
	options: string[];
	default: string;
	group: string | null;
}

interface MetaFile {
	name: string;
	group?: string | null;
	defaultVariant?: string;
	variants?: Record<string, unknown>;
}

async function loadMetaFile(componentDir: string): Promise<MetaFile | null> {
	const metaPath = path.join(componentDir, "meta.ts");

	if (!fs.existsSync(metaPath)) {
		return null;
	}

	// Import the meta file dynamically
	try {
		const module = await import(metaPath);
		return module.default as MetaFile;
	} catch (error) {
		console.error(`Failed to load ${metaPath}:`, error);
		return null;
	}
}

async function collectVariants(): Promise<Map<string, VariantInfo>> {
	const variants = new Map<string, VariantInfo>();

	const components = fs.readdirSync(REGISTRY_UI_DIR).filter((f) => {
		const stat = fs.statSync(path.join(REGISTRY_UI_DIR, f));
		return stat.isDirectory();
	});

	for (const component of components) {
		const meta = await loadMetaFile(path.join(REGISTRY_UI_DIR, component));

		if (!meta?.variants || !meta.defaultVariant) {
			continue;
		}

		const variantKeys = Object.keys(meta.variants);

		variants.set(meta.name, {
			options: variantKeys,
			default: meta.defaultVariant,
			group: meta.group ?? null,
		});
	}

	return variants;
}

function collectGroups(variants: Map<string, VariantInfo>): Map<string, string[]> {
	const groups = new Map<string, string[]>();

	for (const [name, info] of variants) {
		if (info.group) {
			const existing = groups.get(info.group) ?? [];
			existing.push(name);
			groups.set(info.group, existing);
		}
	}

	// Sort component names within each group
	for (const [group, components] of groups) {
		groups.set(group, components.sort());
	}

	return groups;
}

function generateCode(variants: Map<string, VariantInfo>, groups: Map<string, string[]>): string {
	const lines: string[] = [
		"/**",
		" * Auto-generated by scripts/build-registry.ts",
		" * DO NOT EDIT MANUALLY",
		" */",
		"",
	];

	// Generate VARIANTS constant
	lines.push("export const VARIANTS = {");

	const sortedVariants = [...variants.entries()].sort(([a], [b]) => a.localeCompare(b));

	for (const [name, info] of sortedVariants) {
		const optionsStr = info.options.map((o) => `"${o}"`).join(", ");
		lines.push(`\t"${name}": {`);
		lines.push(`\t\toptions: [${optionsStr}] as const,`);
		lines.push(`\t\tdefault: "${info.default}",`);
		lines.push(`\t\tgroup: ${info.group ? `"${info.group}"` : "null"},`);
		lines.push("\t},");
	}

	lines.push("} as const;");
	lines.push("");

	// Generate VARIANT_GROUPS constant
	lines.push("/** Component groups for style editor UI */");
	lines.push("export const VARIANT_GROUPS = {");

	const sortedGroups = [...groups.entries()].sort(([a], [b]) => a.localeCompare(b));

	for (const [group, components] of sortedGroups) {
		const componentsStr = components.map((c) => `"${c}"`).join(", ");
		lines.push(`\t"${group}": [${componentsStr}],`);
	}

	lines.push("} as const;");
	lines.push("");

	// Generate types
	lines.push("export type VariantKey = keyof typeof VARIANTS;");
	lines.push("export type VariantGroupKey = keyof typeof VARIANT_GROUPS;");
	lines.push("");

	return lines.join("\n");
}

async function main() {
	console.log("Building registry variants...");

	// Ensure output directory exists
	if (!fs.existsSync(OUTPUT_DIR)) {
		fs.mkdirSync(OUTPUT_DIR, { recursive: true });
	}

	const variants = await collectVariants();
	console.log(`Found ${variants.size} components with variants`);

	if (variants.size === 0) {
		console.log("No components with variants found. Writing empty file.");
	}

	const groups = collectGroups(variants);
	console.log(`Found ${groups.size} variant groups`);

	const code = generateCode(variants, groups);
	fs.writeFileSync(OUTPUT_FILE, code);

	console.log(`Generated: ${OUTPUT_FILE}`);
}

main().catch(console.error);
